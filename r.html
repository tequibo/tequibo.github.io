
<head>
  <style>
  body {
    background-color: #20021a;
  }
  </style>
  </head>
<body>
    <canvas id="glCanvas" width="900" height="900"></canvas>
</body>
<script id="vertex-shader-2d" type="notjs">
 
  // an attribute will receive data from a buffer
  attribute vec4 a_position;
 
  // all shaders have a main function
  void main() {
 
    // gl_Position is a special variable a vertex shader
    // is responsible for setting
    gl_Position = a_position;
  }
 
</script>
 
<script id="fragment-shader-2d" type="notjs">
    #define TAU 6.28318530718
    // const uint k = 1103515245U;  // GLIB C
    //const uint k = 134775813U;   // Delphi and Turbo Pascal
    //const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)
    //const uint k = 1664525U;     // Numerical Recipes
    precision mediump float;
    uniform vec2 u_resolution;
    uniform float u_time;
    
    float rand(vec2 uv){
        return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }
    /* Math 2D Transformations */
    mat2 rotate2d(in float angle){
        return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));
    }
    float sdCapsule( vec3 p, vec3 a, vec3 b, float r )
    {
      vec3 pa = p - a, ba = b - a;
      float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
      return length( pa - ba*h ) - r;
    }
    float sdSphere( vec3 p, float s )
    {
      return length(p)-s;
    }
    
    float sdBox( vec3 p, vec3 b )
    {
      vec3 q = abs(p) - b;
      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
    }
    float sdRoundBox( vec3 p, vec3 b, float r )
    {
      vec3 q = abs(p) - b;
      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
    }
    float sdPlane( vec3 p, vec3 n, float h )
    {
      // n must be normalized
      return dot(p,n) + h;
    }
    
    float opSmoothUnion( float d1, float d2, float k )
    {
        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
        return mix( d2, d1, h ) - k*h*(1.0-h);
    }
    float opSmoothSubtraction( float d1, float d2, float k ) {
        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
        return mix( d2, -d1, h ) + k*h*(1.0-h); }
    
    float opSmoothIntersection( float d1, float d2, float k ) {
        float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
        return mix( d2, d1, h ) + k*h*(1.0-h); }
        
    float opUnion( float d1, float d2 ) { return min(d1,d2); }
    
    float opSubtraction( float d1, float d2 ) { return max(-d1,d2); }
    
    float opIntersection( float d1, float d2 ) { return max(d1,d2); }
    
    float map(vec3 point){
        float dist = 0.;
        // point.y+=sin(u_time)*1.;
        vec3 p = point;
        float c = .2;
        // p.x=mod(p.x+0.5*c,c)-0.5*c;
        // p.xy=p.xy*rotate2d(TAU*.4+u_time*TAU*.1);
        // p.xz=p.xz*rotate2d(TAU*.4+u_time*TAU*.1);
        
        // p.y+=.1;//*(mod(p.x*2.,2.);
        //  p.z=p.z-.3;
        //  p.xy = p.xy*rotate2d(TAU*u_time*.1);
        float d = sin(p.x*40.+u_time)*sin(p.y*60.+u_time)*sin(p.z*42.+u_time);
        p=point;
        p.xz = p.xz*rotate2d(-TAU*u_time*.1);
        float capsule = sdCapsule(p, vec3(0),vec3(0,0,1),.2);
        // float box = sdBox(p,vec3(
        //                 .315+.04*sin(p.y*2.+u_time*1.*TAU),
        //                 .205+.04*cos(p.z*2.+u_time*1.*TAU),
        //                 .115+.04*sin(p.x*2.+u_time*1.*TAU)
        //                 ));  
        float box = sdBox(p,vec3(
                        .315,
                        .205,
                        .115
                        )); 
        float sphere = sdSphere(p, .35);
        p=point;
        float plane = sdPlane(p, vec3(0,1.0,.0),.3);//p.y+0.4;
        dist = box;
        //  dist=opIntersection(sphere, box)+d*.004;
        // dist=opSubtraction(sphere, box);
        dist=opSmoothUnion(box,sphere,.1);
        // dist = capsule;
        //  dist = min(dist,plane);
        //   dist=max(plane,dist);
        // dist *=sdSphere(p, 0.1);
        return dist;
    }
    
    float rayMarch(vec3 rayOrigin, vec3 rayDirection){
        float rayLength=0.;
        for(int i=0;i<55;i++){
            vec3 point = rayOrigin+rayDirection*rayLength;
            float dist = map(point);
            rayLength+=dist;
            if(dist<.0001 || rayLength>4.0){
                break;
            }
        }
        return rayLength;
    }
    
    vec3 getNormal(vec3 point){
        float dist = map(point);
        vec2 e = vec2(.01, 0);
        vec3 n = dist - vec3(
            map(point-e.xyy),
            map(point-e.yxy),
            map(point-e.yyx));
        return normalize(n);    
    }
    
    vec3 getLight(vec3 point, vec3 position, vec3 color){
        vec3 lightDirection = normalize(position - point);
        vec3 normal = getNormal(point);
        vec3 diffuse = vec3(clamp(dot(normal, lightDirection),0.,1.));
        //  diffuse += dot(normal, vec3(0,1,0));
        diffuse = diffuse*color;
        vec3 p = point;
        p.yz = p.yz*rotate2d(TAU/8.);
        // diffuse+=step(cos(p.y*151.+u_time),.0)*vec3(0.5137, 0.8863, 0.6667);
        // float shadow = 0.0;
        // float shadowRayCount =1.0;
        // for(float i=0.; i<shadowRayCount; i++){
        //     // vec3 r = hash(uvec3(lightDirection+i))*2.-1.;
        //     float r = rand(lightDirection.xz)*2.-1.;
        //     float d = rayMarch(point+normal*.001, lightDirection);
        //         if(d<length(position-point)) {
        //             // diffuse=-diffuse;
        //             diffuse*=.5;
        //             shadow+=1.;
        //         }
        //     }
        // diffuse = mix(diffuse, diffuse*.5, shadow/shadowRayCount);
        return diffuse;
    }
    void main() {
        vec2 R = u_resolution.xy;
        vec2 uv = (2.*gl_FragCoord.xy-R)/R.x;
        vec3 ro = vec3(0., 0., -1.);
        // vec4 m = iMouse/R.x;
        // mat2 rot = rotate2d(TAU*(m.z-m.x));
        mat2 rot = rotate2d(TAU*u_time*.1);
        // mat2 rot2 = rotate2d(TAU*(m.w-m.y));
        mat2 rot2 = rotate2d(TAU*.1);
        ro.yz=ro.yz*rot2;
        // ro.xz=ro.xz*rot;
        vec3 rd = vec3(uv.x, uv.y, 1);
        rd.yz=rd.yz*rot2;
        // rd.xz=rd.xz*rot;
    
        float d = rayMarch(ro, rd);
        vec3 p = ro+rd*d;
        vec3 dif1 = getLight(p, vec3(.5, 1, -1.), vec3(0.46, 0.92, 0.08));
        vec3 dif2 = getLight(p, vec3(-1, 1, -1.), vec3(0.8784, 0.0706, 0.8118));
        vec3 dif3 =  getLight(p, vec3(0, -1, -1.), vec3(1.0, 0.9961, 0.9922));
        // dif+=.5+smoothstep(0.8,1.,dif);    
        
    
        vec3 col = vec3(0.);
        // col = mix(dif1,dif2,.5);
        col=dif1*1.5+dif2;//.+dif3;
        // col=abs(getNormal(p));
        // col = col*(3.-d);
        if(d>1.1){
            // vec3 col2=mix(vec3(0.1608, 0.0, 0.0627),vec3(0.7529, 0.7882, 0.2353),
            // pow(abs(uv.y),1.+.5*sin(u_time)));
            // col=mix(col,col2,.9);
            col=vec3(0);
        }
        vec3 normal = getNormal(p);
        // col += clamp(dot(normal, vec3(0,1,1))*1.5,0.,1.);
        // col += clamp(dot(normal, vec3(0,-1,0))*.2,0.,1.);
        col = pow(col, vec3(0.4545));
        // fragColor=vec4(mix(col,vec3(0.4196, 0.0353, 0.5686),normal), 1.);
        gl_FragColor=vec4(col, 1.);
    }
</script>

<script>
/* eslint no-console:0 consistent-return:0 */
"use strict";

function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }
  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }

  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

var canvas = document.querySelector("#glCanvas");
var gl = canvas.getContext("webgl");
if (!gl) {
    // return;
}
var vertexShaderSource = document.querySelector("#vertex-shader-2d").text;
var fragmentShaderSource = document.querySelector("#fragment-shader-2d").text;
var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
var program = createProgram(gl, vertexShader, fragmentShader);
var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
var colorUniformLocation = gl.getUniformLocation(program, "u_color");  
var timeUniformLocation = gl.getUniformLocation(program, "u_time");  
var resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
var positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
gl.useProgram(program);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,-1, 1, 1, -1, 1,-1,-1,1,1,1,]), gl.STATIC_DRAW); 
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(positionAttributeLocation);
gl.uniform3f(colorUniformLocation, Math.random(), Math.random(), Math.random());
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);      
var time_old = 0;

var draw=function(time){
    var dt = time-time_old;
    time_old = time;
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform1f(timeUniformLocation, time*.001);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    window.requestAnimationFrame(draw);
    if(Math.random()>.9){
        gl.uniform3f(colorUniformLocation, Math.random(), Math.random(), Math.random());
    }
}
// main();
draw(0);
</script>
